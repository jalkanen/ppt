/*
    PROJECT: ppt
    MODULE:  C-code

    A new style loader.
*/

#include <ppt.h>

/*
    First, some compiler stuff to make this compile on SAS/C too.
*/

#ifdef _DCC
#define SAVEDS __geta4
#define ASM
#define REG(x) __ ## x
#define FAR    __far
#else
#define SAVEDS __saveds
#define ASM    __asm
#define REG(x) register __ ## x
#define FAR    __far
#endif

#undef DEBUG_MODE

#ifdef DEBUG_MODE
#define D(x)    x;
#define bug     PDebug
#else
#define D(x)
#define bug     a_function_that_does_not_exist
#endif

/*
    Here are some includes you might find useful. Actually, not all
    of them are required, but I find it easier to delete extra files
    than add up forgotten ones.
*/

#ifndef UTILITY_TAGITEM_H
#include <utility/tagitem.h>
#endif

#include <libraries/bgui.h>
#include <libraries/bgui_macros.h>

#include <clib/alib_protos.h>

#include <proto/exec.h>
#include <proto/intuition.h>
#include <proto/utility.h>
#include <proto/dos.h>
#include <proto/bgui.h>

/*
    These are required, however. Make sure that these are in your include path!
*/

#include <ppt.h>
#include <pragmas/pptsupp_pragmas.h>

/*
    Just some extra, again.
*/

#include <stdio.h>
#include <stdarg.h>
#include <ctype.h>
#include <string.h>

/*----------------------------------------------------------------------*/
/* Defines */

/*
    You should define this to your module name. Try to use something
    short, as this is the name that is visible in the PPT filter listing.
*/

#define MYNAME      "C-code"

/*----------------------------------------------------------------------*/
/* Global variables. Generally, you should keep these to the minimum,
   as it may well be that two copies of this same code is run at
   the same time. */

/*
    Just a simple string describing this effect.
*/

const char infoblurb[] =
    "Saves chunky C code";

/*
    This is the global array describing your effect. For a more detailed
    description on how to interpret and use the tags, see docs/tags.doc.
*/

const struct TagItem MyTagArray[] = {

    /*
     *  Tells the capabilities of this loader/saver unit.
     */

    PPTX_Load,          FALSE,
    PPTX_ColorSpaces,   CSF_RGB|CSF_GRAYLEVEL|CSF_LUT,

    /*
     *  Here are some pretty standard definitions. All iomodules should have
     *  these defined.
     */

    PPTX_Name,          (ULONG) MYNAME,

    /*
     *  Other tags go here. These are not required, but very useful to have.
     */

    PPTX_Author,        (ULONG)"Janne Jalkanen 1997",
    PPTX_InfoTxt,       (ULONG)infoblurb,

    PPTX_RexxTemplate,  (ULONG)NULL,

    PPTX_ReqPPTVersion, 4,

    PPTX_PreferredPostFix,(ULONG)".c",

    TAG_END, 0L
};


/*----------------------------------------------------------------------*/
/* Code */

#ifdef __SASC
/* Disable SAS/C control-c handling. */
void __regargs __chkabort(void) {}
void __regargs _CXBRK(void) {}
#endif

SAVEDS ASM
int __UserLibInit( REG(a6) struct Library *EffectBase )
{
    return 0;
}


SAVEDS ASM
VOID __UserLibCleanup( REG(a6) struct Library *EffectBase )
{
}

SAVEDS ASM
ULONG LIBIOInquire( REG(d0) ULONG attr, REG(a5) EXTBASE *ExtBase )
{
    return TagData( attr, MyTagArray );
}

/*
    This must always exist!
*/

SAVEDS ASM BOOL
LIBIOCheck( REG(d0) BPTR fh, REG(d1) LONG len,
            REG(a0) UBYTE *buf, REG(a5) EXTBASE *ExtBase )
{
    D(bug("IOCheck()\n"));
    return FALSE;
}

SAVEDS ASM PERROR
LIBIOLoad( REG(d0) BPTR fh,               REG(a0) FRAME *frame,
           REG(a1) struct TagItem *tags,  REG(a5) EXTBASE *ExtBase )
{
    D(bug("IOLoad()\n"));
    SetErrorCode(frame,PERR_MISSINGCODE);
    return PERR_ERROR;
}


PERROR fhprintf(BPTR fh, EXTBASE *ExtBase, const char *c, ... )
{
    va_list va;
    char buf[4096];
    struct DosLibrary *DOSBase = ExtBase->lb_DOS;

    va_start(va,c);
    vsprintf(buf,c,va);
    va_end(va);

    if(FPuts(fh,buf))
        return PERR_FILEWRITE;

    return PERR_OK;
}

PERROR WriteHeader( FRAME *frame, STRPTR basename, BPTR fh, EXTBASE *ExtBase )
{
    struct Extension *anno;
    PERROR res;

    anno = FindExtension(frame,EXTNAME_ANNO);

    res = fhprintf(fh,ExtBase,
                "/*\n"
                " *   This file automatically generated by PPT version %d.%d\n",
                ExtBase->lib.lib_Version, ExtBase->lib.lib_Revision );

    res = fhprintf(fh,ExtBase,
                " *\n"
                " *  %s\n"
                " */", anno ? anno->en_Data : "");

    res = fhprintf(fh,ExtBase,
                "\n\n"
                "#include <exec/types.h>\n"
                "\n\n");

    res = fhprintf(fh,ExtBase,
                "\n\n"
                "UWORD   %s_height = %d\n"
                "UWORD   %s_width  = %d\n"
                "UWORD   %s_components = %d\n",
                basename, frame->pix->width,
                basename, frame->pix->height,
                basename, frame->pix->components );


    return res;
}

PERROR WriteFooter( FRAME *frame, BPTR fh, EXTBASE *ExtBase )
{
    PERROR res;

    res = fhprintf(fh,ExtBase,
                "\n};\n"
                "\n\n"
                "/* END OF FILE */\n");
    return res;
}

PERROR WriteColormap( FRAME *frame, STRPTR basename, BOOL alpha, BPTR fh, EXTBASE *ExtBase )
{
    int i;
    PERROR res;

    res = fhprintf(fh,ExtBase,
                "\n"
                "UWORD   %s_colors = %d\n"
                "UBYTE   %s_alpha  = %d\n"
                "UBYTE   %s_cmap = {\n",
                basename,frame->disp->ncolors,
                basename,alpha,
                basename );

    for( i = 0; i < frame->disp->ncolors; i++ ) {
        if( alpha )  {
            res = fhprintf(fh,ExtBase,"    %u,",frame->disp->colortable[i].a);
        } else {
            res = fhprintf(fh,ExtBase,"    ");
        }

        res = fhprintf(fh,ExtBase,
                "%3u,%3u,%3u,\n",
                frame->disp->colortable[i].r,
                frame->disp->colortable[i].g,
                frame->disp->colortable[i].b );
    }

    res = fhprintf(fh,ExtBase,
                  "\n};\n");

    return res;
}

VOID remblanks( STRPTR src, STRPTR dst, ULONG len )
{
    ULONG i,j = 0;

    for( i = 0; i < strlen(src) && i < len; i++ ) {
        if( (j && isalnum(src[i])) || (!j && isalpha(src[i])) ) {
            dst[j++] = src[i];
        }
    }

    dst[j] = '\0';
}

/*
    Format can be any of CSF_* - flags
*/
SAVEDS ASM PERROR
LIBIOSave( REG(d0) BPTR fh,       REG(d1) ULONG format,
           REG(a0) FRAME *frame,  REG(a1) struct TagItem *tags,
           REG(a5) EXTBASE *ExtBase )
{
    WORD row, col;
    char basename[256];
    PERROR res;

    D(bug("IOSave(type=%08X)\n",format));

    remblanks( frame->name, basename, 255 );

    if( (res = WriteHeader( frame, basename, fh, ExtBase )) != PERR_OK ) {
        SetErrorCode(frame,res);
        return PERR_ERROR;
    }

    if( format == CSF_LUT ) {
        if( (res = WriteColormap( frame, basename, FALSE, fh, ExtBase )) != PERR_OK ) {
            SetErrorCode(frame,res);
            return PERR_ERROR;
        }
    }

    InitProgress(frame,"Writing C source code...",0,frame->pix->height);

    res = fhprintf(fh,ExtBase,
                    "\n\n"
                    "UBYTE %s_data[] = {",
                    basename);

    for( row = 0; row < frame->pix->height; row++ ) {

        if( Progress( frame, row )) {
            return PERR_BREAK;
        }

        if( format != CSF_LUT ) {
            ROWPTR cp;

            cp = GetPixelRow( frame, row );

            for( col = 0; col < frame->pix->width*frame->pix->components; col++ ) {
                if( col % 20 == 0 ) fhprintf(fh,ExtBase,"\n    ");
                res = fhprintf( fh, ExtBase, "0x%02X,", cp[col] );
            }
        } else {
            UBYTE *cp;

            cp = GetBitMapRow( frame, row );

            for( col = 0; col < frame->pix->width; col++ ) {
                if( col % 20 == 0 ) {
                    fhprintf(fh,ExtBase,"\n    ");
                }
                res = fhprintf( fh, ExtBase, "0x%02X,", cp[col] );
            }

        }

        if( res != PERR_OK ) {
            SetErrorCode( frame, res );
            return PERR_ERROR;
        }
    }

    if( (res = WriteFooter( frame, fh, ExtBase )) != PERR_OK ) {
        SetErrorCode( frame, res );
        return PERR_ERROR;
    }

    FinishProgress( frame );

    return PERR_OK;
}

/*----------------------------------------------------------------------*/
/*                            END OF CODE                               */
/*----------------------------------------------------------------------*/

